import { Channel, StoryId } from '@storybook/addons';
import { Call, CallRef, LogItem } from './types';
export declare const EVENTS: {
    CALL: string;
    SYNC: string;
    LOCK: string;
    START: string;
    BACK: string;
    GOTO: string;
    NEXT: string;
    END: string;
};
export interface Options {
    intercept?: boolean | ((method: string, path: Array<string | CallRef>) => boolean);
    retain?: boolean;
    mutate?: boolean;
    path?: Array<string | CallRef>;
    getArgs?: (call: Call, state: State) => Call['args'];
}
export interface State {
    renderPhase: 'loading' | 'rendering' | 'playing' | 'played' | 'completed' | 'aborted' | 'errored';
    isDebugging: boolean;
    cursor: number;
    calls: Call[];
    shadowCalls: Call[];
    callRefsByResult: Map<any, CallRef & {
        retain: boolean;
    }>;
    chainedCallIds: Set<Call['id']>;
    parentCall?: Call;
    playUntil?: Call['id'];
    resolvers: Record<Call['id'], Function>;
    syncTimeout: ReturnType<typeof setTimeout>;
    forwardedException?: Error;
}
export declare type PatchedObj<TObj> = {
    [Property in keyof TObj]: TObj[Property] & {
        __originalFn__: PatchedObj<TObj>;
    };
};
/**
 * This class is not supposed to be used directly. Use the `instrument` function below instead.
 */
export declare class Instrumenter {
    channel: Channel;
    initialized: boolean;
    state: Record<StoryId, State>;
    constructor();
    getState(storyId: StoryId): State;
    setState(storyId: StoryId, update: Partial<State> | ((state: State) => Partial<State>)): void;
    cleanup(): void;
    getLog(storyId: string): LogItem[];
    instrument<TObj extends {
        [x: string]: any;
    }>(obj: TObj, options: Options): PatchedObj<TObj>;
    track(method: string, fn: Function, args: any[], options: Options): PatchedObj<any>;
    intercept(fn: Function, call: Call, options: Options): any;
    invoke(fn: Function, call: Call, options: Options): any;
    sync(call: Call): void;
}
/**
 * Instruments an object or module by traversing its properties, patching any functions (methods)
 * to enable debugging. Patched functions will emit a `call` event when invoked.
 * When intercept = true, patched functions will return a Promise when the debugger stops before
 * this function. As such, "interceptable" functions will have to be `await`-ed.
 */
export declare function instrument<TObj extends Record<string, any>>(obj: TObj, options?: Options): TObj;
